from solidstatesynth.gen.build_rxn import BuildRxn, AnalyzeEnumeratedRxns
from solidstatesynth.extract.tm import get_updated_textmined_data
from pydmclab.utils.handy import read_json
from pydmclab.core.comp import CompTools
import os 

DATA_DIR = "/Volumes/cems_bartel/projects/negative-examples/data"

def relevant_entry(entry):
    if 'positive' not in entry:
        return False
    if len(entry['common']['precursors']) > 3:
        return False
    if len(entry['common']['precursors']) == 3:
        if any(CompTools(precursor).clean in ['O1', 'H2O1','C1O2'] for precursor in entry['common']['precursors']):
            return True
        else:
            return False
    target_els = CompTools(entry['positive']['target']).els
    if 'O' in target_els:
        if len(target_els) <= 4:
            return True
    elif len(target_els) <= 3:
        return True
    return False

def get_relevant_textmined():
    textmined = get_updated_textmined_data()
    relevant_textmined = []
    for entry in textmined:
        if relevant_entry(entry):
            relevant_textmined.append(entry)
    return relevant_textmined

def find_opt_for_entry(entry):
    target = entry['positive']['target']
    temperature = entry['common']['temperature']
    if not temperature:
        temperature = 1000  
    rxns = BuildRxn(target=target,temperature=temperature).build_target_rxns()
    opt = AnalyzeEnumeratedRxns(rxns).optimum_rxn
    return opt

def find_actual_for_entry(entry):
    target = entry['positive']['target']
    temperature = entry['common']['temperature']
    precursors = entry['common']['precursors']
    if not temperature:
        temperature = 1000
    rxns = BuildRxn(target=target,temperature=temperature).build_target_rxns(found_precursors=precursors)
    return rxns

def compare(entry):
    opt = find_opt_for_entry(entry)
    actual = find_actual_for_entry(entry)
    return {'opt':opt, 'actual':actual}

def get_reaction_dict_from_string(reaction_string):
    """
    Args: reaction string
    Returns: dictionary with keys 'reactants' and 'products' where
    the values are lists of the reactants and products in the reaction
    *** IF CLEANABLE -- otherwise returns None ***
    Uses: this is the most usable reaction format from which to calculate
    dG_rxn using the pydmclab ReactionEnergy class-- get_dGrxn_at_T takes
    a reaction dictionary as an argument
    """
    reactant_list = []
    reactant_coeffs = []
    product_list = []
    product_coeffs = []
    if '->' in reaction_string:
        reactants, products = reaction_string.split(" -> ")
        # print(reactants)
    elif '==' in reaction_string:
        reactants, products = reaction_string.split(" == ")
    if "+" in reactants:
        reactants = reactants.split(" + ")
    else:
        reactants = [reactants]
    # print('reactants', reactants)
    for reactant in reactants:
        if " " in reactant:
            if len(reactant.split(" ")) != 1:
                coefficient, reactant = reactant.split(" ")
                if float(coefficient) > 0:
                    try:
                        CompTools(reactant).clean
                        reactant_list.append(reactant)
                        reactant_coeffs.append(coefficient)
                    except:
                        return None
        else:
            reactant_list.append(reactant)
            reactant_coeffs.append(1)
    if "+" in products:
        products = products.split(" + ")
    else:
        products = [products]
    for product in products:
        if " " in product:
            if len(product.split(" ")) != 1:
                coefficient, product = product.split(" ")
                if float(coefficient) > 0:
                    try:
                        CompTools(product).clean
                        product_list.append(product)
                        product_coeffs.append(coefficient)
                    except:
                        return None
        else:
            product_list.append(product)
            product_coeffs.append(1)
    # print(reactant_list,product_list)
    return {"reactants": reactant_list, "products": product_list, 
            "reactant_coeffs": reactant_coeffs, "product_coeffs": product_coeffs}


def get_competitions():
    fjson = os.path.join(DATA_DIR, "240705_mcdermott_data.json")
    competition = read_json(fjson)
    competitions = [entry for entry in competition['Sheet1'] if 'open' in entry]
    new_entries = []
    for entry in competitions:
        rxn_dict = get_reaction_dict_from_string(entry['reaction'])
        temp = float(entry['temp_degC']) + 273.15
        if temp > 2000:
            temp = 2000
        entry_new = {'precursors': rxn_dict['reactants'],  'temp': temp}
        target = [formula for formula in rxn_dict['products'] if CompTools(formula).clean not in ['O1', 'H2O1','C1O2']][0]
        entry_new['target'] = target
        new_entries.append(entry_new)
    return new_entries

def get_rxn_from_comp(competition_entry):
    target = competition_entry['target']
    precursors = competition_entry['precursors']
    temp = competition_entry['temp']
    build = BuildRxn(target = target, temp = temp)
    filtered_rxns = build.filtered_rxns()
    opt_rxn = build.optimum_rxn()
    if not opt_rxn:
        opt_gamma = None
    else:
        opt_gamma = opt_rxn['gamma']
    true_rxn = build.filter_reactions_by_precursors(precursors, filtered_rxns)
    if true_rxn:
        true_gamma = true_rxn['gamma']
    else:
        true_gamma = None
    return {'opt':opt_gamma, 'true':true_gamma}

def get_competition_rxns(length = 200):
    competitions = get_competitions()
    competition_rxns = []
    for i, competition in enumerate(competitions[0:length]):
        print(i)
        competition_rxns.append(get_rxn_from_comp(competition))
    return competition_rxns

def main():
    tm = get_relevant_textmined()
    return tm

if __name__ == "__main__":
    tm = main()
