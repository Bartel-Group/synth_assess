from solidstatesynth.gen.build_rxn import BuildRxn, AnalyzeEnumeratedRxns
from solidstatesynth.gen.metrics_calculation import TargetRxns
from solidstatesynth.extract.tm import get_updated_textmined_data
from pydmclab.utils.handy import read_json
from pydmclab.core.comp import CompTools
import os 

DATA_DIR = "/Users/schle759/Documents"

def relevant_entry(entry):
    if 'positive' not in entry:
        return False
    if len(entry['common']['precursors']) > 3:
        return False
    if len(entry['common']['precursors']) == 3:
        if any(CompTools(precursor).clean in ['O1', 'H2O1','C1O2'] for precursor in entry['common']['precursors']):
            return True
        else:
            return False
    target_els = CompTools(entry['positive']['target']).els
    if 'O' in target_els:
        if len(target_els) <= 4:
            return True
    elif len(target_els) <= 3:
        return True
    return False

def get_relevant_textmined():
    textmined = get_updated_textmined_data()
    relevant_textmined = []
    for entry in textmined:
        if relevant_entry(entry):
            relevant_textmined.append(entry)
    return relevant_textmined

def find_rxns(target,temperature):
    target = entry['positive']['target']
    temperature = entry['common']['temperature']
    if not temperature:
        temperature = 1000  
    rxns = BuildRxn(target=target,temperature=temperature).build_target_rxns()
    return rxns

def find_opt(rxns):
    optimum = AnalyzeEnumeratedRxns(rxns).optimum_rxn()
    return optimum

def find_actual_for_entry(rxns,precursors,target,temperature):
    precursors = entry['common']['precursors']
    actual = TargetRxns(precursors = precursors, target=target,temperature=temperature,reactions = rxns).get_rxns_with_desired_precursors()
    return actual



def compare_entry(entry):
    temperature = entry['common']['temperature']
    if not temperature:
        temperature = 1000
    precursors = entry['common']['precursors']
    target = entry['positive']['target']
    rxns = find_rxns(target,temperature)
    # opt = find_opt(rxns)
    actual = find_actual_for_entry(rxns,precursors,target,temperature)
    return opt,actual

def compare(entry):
    opt = find_opt_for_entry(entry)
    actual = find_actual_for_entry(entry)
    return {'opt':opt, 'actual':actual}

def get_reaction_dict_from_string(reaction_string):
    """
    Args: reaction string
    Returns: dictionary with keys 'reactants' and 'products' where
    the values are lists of the reactants and products in the reaction
    *** IF CLEANABLE -- otherwise returns None ***
    Uses: this is the most usable reaction format from which to calculate
    dG_rxn using the pydmclab ReactionEnergy class-- get_dGrxn_at_T takes
    a reaction dictionary as an argument
    """
    reactant_list = []
    reactant_coeffs = []
    product_list = []
    product_coeffs = []
    if '->' in reaction_string:
        reactants, products = reaction_string.split(" -> ")
        # print(reactants)
    elif '==' in reaction_string:
        reactants, products = reaction_string.split(" == ")
    if "+" in reactants:
        reactants = reactants.split(" + ")
    else:
        reactants = [reactants]
    # print('reactants', reactants)
    for reactant in reactants:
        if " " in reactant:
            if len(reactant.split(" ")) != 1:
                coefficient, reactant = reactant.split(" ")
                if float(coefficient) > 0:
                    try:
                        CompTools(reactant).clean
                        reactant_list.append(reactant)
                        reactant_coeffs.append(coefficient)
                    except:
                        return None
        else:
            reactant_list.append(reactant)
            reactant_coeffs.append(1)
    if "+" in products:
        products = products.split(" + ")
    else:
        products = [products]
    for product in products:
        if " " in product:
            if len(product.split(" ")) != 1:
                coefficient, product = product.split(" ")
                if float(coefficient) > 0:
                    try:
                        CompTools(product).clean
                        product_list.append(product)
                        product_coeffs.append(coefficient)
                    except:
                        return None
        else:
            product_list.append(product)
            product_coeffs.append(1)
    # print(reactant_list,product_list)
    return {"reactants": reactant_list, "products": product_list, 
            "reactant_coeffs": reactant_coeffs, "product_coeffs": product_coeffs}


def get_competitions():
    fjson = os.path.join(DATA_DIR, "mcdermott.json")
    competition = read_json(fjson)
    competitions = [entry for entry in competition if 'open' in entry]
    new_entries = []
    for entry in competitions:
        rxn_dict = get_reaction_dict_from_string(entry['reaction'])
        temp = float(entry['temp_degC']) + 273.15
        if temp > 2000:
            temp = 2000
        entry_new = {'precursors': rxn_dict['reactants'],  
        'temp': temp, 'energy': entry['energy'],
        'c1': entry['c1'], 'c2': entry['c2']}
        target = [formula for formula in rxn_dict['products'] if CompTools(formula).clean not in ['O1', 'H2O1','C1O2']][0]
        entry_new['target'] = target
        new_entries.append(entry_new)
    return new_entries

def get_rxn_from_comp(competition_entry):
    target = competition_entry['target']
    precursors = competition_entry['precursors']
    temp= competition_entry['temp']
    build = BuildRxn(target = target, temperature = temp)
    true_rxn = build.build_target_rxns(found_precursors=precursors)
    # # opt_rxn = build.optimum_rxn()
    # # if not opt_rxn:
    # #     opt_gamma = None
    # # else:
    # #     opt_gamma = opt_rxn['gamma']
    # true_rxn = build.filter_reactions_by_precursors(precursors, filtered_rxns)
    if true_rxn:
        if true_rxn[0]:
            true_energy = true_rxn[0]['energy']
    else:
        true_energy = None
    return {'true':competition_entry['energy'],'calc':true_energy, 
    'target':target, 'temperature':temp, 
    'c1': competition_entry['c1'], 'c2': competition_entry['c2']}

def get_competition_rxns(a):
    competitions = get_competitions()
    competition_rxns = []
    for i, competition in enumerate(competitions[a:a+20]):
        r =get_rxn_from_comp(competition)
        print(r)
        competition_rxns.append(r)
    return competition_rxns

# def main():
#     # tm = get_relevant_textmined()
#     # return tm

# if __name__ == "__main__":
#     main()
